{
  "hash": "1b46d91614b9d13c104b2c4c6c585de1",
  "result": {
    "markdown": "---\ntitle: 'Bayesian Data Analysis: Week 5 -> Metropolis '\nauthor: ''\ndate: '2020-06-29'\nslug: bayesian-data-analysis-week-5-metropolis\ncategories: []\ntags: []\naliases:\n  - ../../2020/06/29/bayesian-data-analysis-week-5-metropolis/\n---\n\n\n\n\nBayesian Data Analysis (Gelman, Vehtari et. alter) is equals part a great introduction and THE reference for advanced Bayesian Statistics. Luckily, it's [freely available online](http://www.stat.columbia.edu/~gelman/book/). To make things even better for the online learner, Aki Vehtari (one of the authors) has a set of online lectures and homeworks that go through the basics of Bayesian Data Analysis.\n\nSo far in the course, we have seen how the main obstacle in the way of performing Bayesian Statistics is the computation of the posterior. Thus, we must ask ourselves: if we *cannot fully* compute the **posterior**, but we *can* evaluate an unnormalized version, how can we **approximate** the posterior distribution? \n\nIn this week, we started analyzing a promising alternative: **Monte-Carlo Markov Chains (MCMC)**. In this blogpost, I'll give a succinct overview of the most basic MCMC algorithm: the *Metropolis Algorithm* and quick example of it with some real data.\n\n## A Monte-Carlo Markov Chain\n\nThe **Metropolis** Algorithm is just a random walk through parameter space. At each iteration of the algorithm, say $t$, where we are depends only on where we were at $t-1$. That is $P(\\theta_t | \\theta_{t-1}, \\theta_{t-2}, \\cdots, \\theta_{0}) = P(\\theta_t | \\theta_{t-1}$. This is the *Markov* part. At each time step, then, we must define transition distribution: the probability of $P(\\theta_t | \\theta_{t-1})$. \n\nThe Monte-Carlo part comes because we use these different samples $(\\theta_{t-1}, \\theta_{t-2}, \\cdots, \\theta_{0})$ to estimate the posterior distribution. We can only do this if at time step $T \\to \\infty$, $P(\\theta_T) = P(\\theta_T | y)$. That is, if the stationary distribution (the probability that we are at any given point in time $T$) is the target posterior distribution. The *challenge* then, is **how to engineer each transition distribution such that the stationary distribution is the posterior.** We will check how the Metropolis algorithm solves this problem with a numerical example. \n\nIf we can construct such a Markov Chain, then our *Monte-Carlo estimate*s using these samples will be **asymptotically consistent**. However, two problems arise: first, there's an *auto-correlation* in our samples from the Markov chains. Although the Central Limit Theorem still holds, our **effective sample size for our Monte-Carlo estimates will be lower than our number of Markov Chain iterations**. Secondly, we cannot know if we have run the Markov Chain long enough such that our samples are in proportion according to their stationary distribution: that is, **we cannot know if the chains have converged toward the posterior distribution**.  We will check both problems with convergence diagnostics once we have worked out a numerical example of the Metropolis algorithm.  \n\n## The Metropolis Algorithm\n\nThe Metropolis algorithm is thus defined. A random walk through parameter space such that at each iteration of the Markov Chain, our samples are corrected such that they approximate our posterior distribution. In particular, begin at some point $\\theta_{0}$. Then, we generate a proposed move by direct sampling from a proposal distribution: say a normal centered around $\\theta_{0}$. The suggestion then is $\\theta^*$. We will then decide if we move to $\\theta^*$ by comparing the ratio of unnormalized posterior distribution densities at $\\theta^*$ and $\\theta_{0}$.\n\n$$\nr = \\dfrac{q(\\theta^*|y)}{q(\\theta_0| y)}\n$$\nWhich, given that both are normalized by the same constant in the posterior distribution, is equivalent to comparing the posterior densities at both points:\n\n$$\n r = \\dfrac{q(\\theta^*|y)}{q(\\theta_0| y)} = \\dfrac{q(\\theta^*|y) / \\int q(\\theta|y) d\\theta}{q(\\theta_0| y)/ \\int q(\\theta|y) d\\theta} =  \\dfrac{p(\\theta^*|y)}{p(\\theta_0 | y)}\n$$\nFinally, we decide whether to move to $\\theta^*$ by a Bernoulli trial with probability $min(r, 1)$. That is:\n\n- if the proposed jump increases the posterior ($p(\\theta^*|y) > p(\\theta_0|y)$), then our Markov Chain moves to $\\theta^*$ and we set $\\theta_t = \\theta^*$.\n- if the proposed jump decreases the posterior ($p(\\theta^*|y) < p(\\theta_0|y)$), then our Markov Chain then we may or may not move to $\\theta^*$. The probability that we do move decreases as the decreased density resulting from the jump increases. \n\nTherefore:\n\n> The Metropolis algorithm can thus be viewed as a stochastic version of a stepwise mode-finding algorithm, always accepting steps that increase the density until it finds the mode and then only sometimes accepting steps that decrease the posterior density. \n\nThus, as long as the algorithm has run long enough to find the posterior mode, **and the area around the mode is a good representation of the overall posterior**, the Metropolis Algorithm will work. \n\n## An example of the Metropolis Algorithm\n\nThe data come from the excellent Bayesian course [Statistical Rethinking](https://xcelab.net/rm/statistical-rethinking/). Which is the best statistics course that I've ever taken. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"Howell1\")\nheights <- Howell1\nskimr::skim(heights)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |        |\n|:------------------------|:-------|\n|Name                     |heights |\n|Number of rows           |544     |\n|Number of columns        |4       |\n|_______________________  |        |\n|Column type frequency:   |        |\n|numeric                  |4       |\n|________________________ |        |\n|Group variables          |None    |\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|   mean|    sd|    p0|    p25|    p50|    p75|   p100|hist  |\n|:-------------|---------:|-------------:|------:|-----:|-----:|------:|------:|------:|------:|:-----|\n|height        |         0|             1| 138.26| 27.60| 53.98| 125.10| 148.59| 157.48| 179.07|▁▂▂▇▇ |\n|weight        |         0|             1|  35.61| 14.72|  4.25|  22.01|  40.06|  47.21|  62.99|▃▂▃▇▂ |\n|age           |         0|             1|  29.34| 20.75|  0.00|  12.00|  27.00|  43.00|  88.00|▇▆▅▂▁ |\n|male          |         0|             1|   0.47|  0.50|  0.00|   0.00|   0.00|   1.00|   1.00|▇▁▁▁▇ |\n:::\n:::\n\n\nWe will therefore model a very simple Gaussian probability model for the height:\n\n$$ \nheight_i \\sim Normal(\\mu, \\sigma) \\\\\n\\mu \\sim Normal(150, 20) \\\\\n\\sigma \\sim Normal(5, 10)\n$$\n\nThus, for a given $\\mu, \\sigma$, the model's log-likelihood is thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_log_likelihood <- function(mu, sigma) {\n  sum(dnorm(heights$height, mu, sigma, log = TRUE))\n}\n```\n:::\n\n\nThe unnormalized posterior is thus the log-likelihood plus the prior density log:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_unnormalized_posterior <- function(mu, sigma) {\n  dnorm(mu, 150, 20, log = TRUE) + dnorm(sigma, 5, 10, log = TRUE) + model_log_likelihood(mu, sigma)\n}\n```\n:::\n\n\nTherefore, if our proposal algorithm is a normal centered around the past iteration with scale of 5 for $\\mu$ and scale of 2 for $\\sigma$, the metropolis algorithm can be written thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity_ratio <- function(alpha_propose, alpha_previous, sigma_propose, sigma_previous) {\n  exp(log_unnormalized_posterior(alpha_propose, sigma_propose) -  log_unnormalized_posterior(alpha_previous, sigma_previous))\n}\n\nsingle_metropolis <- function(total_iter = 10000) {\n    \n  alpha <- vector(length = total_iter)\n  sigma <- vector(length = total_iter)\n  alpha[1] <- runif(1, min = 100, 150) # initialize the chains at random points\n  sigma[1] <- runif(1, min = 10, 40) # initialize the chains at random points\n  for (i in 2:total_iter) {\n    \n    # sample proposal\n    alpha_propose <- rnorm(1, mean = alpha[i-1], sd = 5)\n    sigma_propose <- rnorm(1, mean = sigma[i-1], sd = 2)\n    # compare posterior at past and proposal\n    ratio <- density_ratio(alpha_propose, alpha[i-1], sigma_propose, sigma[i-1])\n    ratio <- min(1, ratio) \n    # check whether you move\n    bool_move <- rbernoulli(1, p = ratio)\n    \n    if (bool_move == 1) {\n      alpha[i] <- alpha_propose\n      sigma[i] <- sigma_propose\n    }\n    \n    else{\n      alpha[i] <- alpha[i-1]\n      sigma[i] <- sigma[i-1]\n    }\n    \n  }\n  list(alpha = alpha[5001:total_iter], sigma = sigma[5001:total_iter])\n}\n```\n:::\n\n\nNotice that we do not use all of our iterations. In fact, we discard half of them. The reason? At the beginning of the chain, the probabilities have not converged to that of the stationary distribution. Thus, they are not correct samples from the posterior distribution. This beginning period serves to *warm-up* the Chains long enough until they find the stationary distribution and start yielding usable samples from the posterior. \n\nTo run multiple chains of the Metropolis algorithm:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiple_metropolis <- function(chains = 4) {\n  alpha <- list()\n  sigma <- list()\n  for (chain in 1:chains) {\n    \n    result_chain <- single_metropolis()\n    alpha[[chain]] <- result_chain[[1]]\n    sigma[[chain]] <- result_chain[[2]]\n  }\n  list(alpha = alpha, sigma = sigma)\n}\n\nresults <- multiple_metropolis()\n```\n:::\n\n\nOur results, then, can be summarised just as we work with Monte-Carlo samples from other methods. For example, the posterior mean can is thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(cbind, results$alpha) %>% \n  data.frame(iter = 1:5000, .) %>% \n  pivot_longer(-iter, values_to = \"alpha\") %>% \n  select(-name) %>% \n  left_join(do.call(cbind, results$sigma) %>% \n    data.frame(iter = 1:5000, .) %>% \n    pivot_longer(-iter, values_to = \"sigma\") %>% \n    select(-name)) -> results_plot\n\nresults_plot %>% \n  select(-iter) %>% \n  summarise_all(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  alpha sigma\n  <dbl> <dbl>\n1  138.  27.5\n```\n:::\n:::\n\n\nWe can visualize the samples from the posterior:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_plot %>% \n  ggplot(aes(alpha, sigma)) +\n  geom_jitter(alpha = 0.1) +\n  labs(title = \"Samples from the posterior\",\n       subtitle = \"Posterior obtained with Metropolis algorithm\")\n```\n\n::: {.cell-output-display}\n![](2020-06-29-bayesian-data-analysis-week-5-metropolis_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Convergence Diagnostics\n\nIf we run multiple chains, we can check whether each chain converged to explore the same areas of the parameter space in the same proportions. If the chains are in not in agreement between each other, then, it's a sure sign that the chains have yet to converge. We can visualize the path that each chain took through the parameter space with trace plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(cbind, results$alpha) %>% \n  data.frame(., iter = 1:5000) %>% \n  pivot_longer(-iter, names_to = \"chain\", names_prefix = \"X\",\n               values_to = \"alpha\") %>% \n  ggplot(aes(iter, alpha, color = chain)) +\n  geom_line() +\n  scale_color_brewer(palette = \"Set2\") +\n  labs(title = \"Trace plot for alpha\",\n       subtitle = \"The chains have converged to explore the same areas\")\n```\n\n::: {.cell-output-display}\n![](2020-06-29-bayesian-data-analysis-week-5-metropolis_files/figure-html/alpha-trace-1.png){width=768}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(cbind, results$sigma) %>% \n  data.frame(., iter = 1:5000) %>% \n  pivot_longer(-iter, names_to = \"chain\", names_prefix = \"X\",\n               values_to = \"sigma\") %>% \n  ggplot(aes(iter, sigma, color = chain)) +\n  geom_line() +\n  scale_color_brewer(palette = \"Set2\") +\n  labs(title = \"Trace plot for sigma\",\n       subtitle = \"The chains have converged to explore the same areas\")\n```\n\n::: {.cell-output-display}\n![](2020-06-29-bayesian-data-analysis-week-5-metropolis_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nA numerical convergence-diagnostic is $\\widehat R$. It measures agreement between the chains by comparing the within chain variance $W$ with the estimated variance using all of the available data $var(\\theta | y)$. If all of the chains have converged, $W$ and $var(\\theta | y)$ should be equal. Thus, $\\widehat R$, which is the squared root of their ratio should be 1:\n\n$$\n\\widehat R = \\sqrt{\\dfrac{Var(\\theta | y)}{W}}\n$$\nHowever, if the chains are in disagreement between each other because they have not converged, they will underestimate the total variance $Var(\\theta | y)$. Why? Because they have yet to explore the full posterior scale. Thus, $\\widehat R$ will be larger than 1. As the chains converge (as the number of iterations grows), we expect $\\widehat R$ to converge to 1 from above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niterations <- c(20, 50, 100, 5000)\nnames(iterations) <- c(20, 50, 100, 5000)\nmap_df(iterations, ~ rstan::Rhat(do.call(cbind, results$alpha)[1:.x])) %>% \n  pivot_longer(everything(), names_to = \"iterations\", values_to = \"Rhat\") %>% \n  gt::gt() %>% \n  gt::fmt_number(vars(Rhat))\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"qrzyiplwex\" style=\"overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>html {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#qrzyiplwex .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#qrzyiplwex .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#qrzyiplwex .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#qrzyiplwex .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#qrzyiplwex .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#qrzyiplwex .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#qrzyiplwex .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#qrzyiplwex .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#qrzyiplwex .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#qrzyiplwex .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#qrzyiplwex .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#qrzyiplwex .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#qrzyiplwex .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qrzyiplwex .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#qrzyiplwex .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#qrzyiplwex .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qrzyiplwex .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#qrzyiplwex .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qrzyiplwex .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#qrzyiplwex .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qrzyiplwex .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#qrzyiplwex .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#qrzyiplwex .gt_left {\n  text-align: left;\n}\n\n#qrzyiplwex .gt_center {\n  text-align: center;\n}\n\n#qrzyiplwex .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#qrzyiplwex .gt_font_normal {\n  font-weight: normal;\n}\n\n#qrzyiplwex .gt_font_bold {\n  font-weight: bold;\n}\n\n#qrzyiplwex .gt_font_italic {\n  font-style: italic;\n}\n\n#qrzyiplwex .gt_super {\n  font-size: 65%;\n}\n\n#qrzyiplwex .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#qrzyiplwex .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#qrzyiplwex .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#qrzyiplwex .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#qrzyiplwex .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#qrzyiplwex .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#qrzyiplwex .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\">\n  \n  <thead class=\"gt_col_headings\">\n    <tr>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">iterations</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">Rhat</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td class=\"gt_row gt_right\">20</td>\n<td class=\"gt_row gt_right\">1.82</td></tr>\n    <tr><td class=\"gt_row gt_right\">50</td>\n<td class=\"gt_row gt_right\">1.16</td></tr>\n    <tr><td class=\"gt_row gt_right\">100</td>\n<td class=\"gt_row gt_right\">1.07</td></tr>\n    <tr><td class=\"gt_row gt_right\">5000</td>\n<td class=\"gt_row gt_right\">1.01</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\nNow, for sigma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niterations <- c(20, 50, 100, 5000)\nnames(iterations) <- c(20, 50, 100, 5000)\nmap_df(iterations, ~ rstan::Rhat(do.call(cbind, results$sigma)[1:.x])) %>% \n  pivot_longer(everything(), names_to = \"iterations\", values_to = \"Rhat\") %>% \n  gt::gt() %>% \n  gt::fmt_number(vars(Rhat))\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"xcfbqrllmp\" style=\"overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>html {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#xcfbqrllmp .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#xcfbqrllmp .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#xcfbqrllmp .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#xcfbqrllmp .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#xcfbqrllmp .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#xcfbqrllmp .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#xcfbqrllmp .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#xcfbqrllmp .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#xcfbqrllmp .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#xcfbqrllmp .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#xcfbqrllmp .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#xcfbqrllmp .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#xcfbqrllmp .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xcfbqrllmp .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#xcfbqrllmp .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#xcfbqrllmp .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xcfbqrllmp .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#xcfbqrllmp .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xcfbqrllmp .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#xcfbqrllmp .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xcfbqrllmp .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#xcfbqrllmp .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#xcfbqrllmp .gt_left {\n  text-align: left;\n}\n\n#xcfbqrllmp .gt_center {\n  text-align: center;\n}\n\n#xcfbqrllmp .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#xcfbqrllmp .gt_font_normal {\n  font-weight: normal;\n}\n\n#xcfbqrllmp .gt_font_bold {\n  font-weight: bold;\n}\n\n#xcfbqrllmp .gt_font_italic {\n  font-style: italic;\n}\n\n#xcfbqrllmp .gt_super {\n  font-size: 65%;\n}\n\n#xcfbqrllmp .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#xcfbqrllmp .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#xcfbqrllmp .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#xcfbqrllmp .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#xcfbqrllmp .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#xcfbqrllmp .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#xcfbqrllmp .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\">\n  \n  <thead class=\"gt_col_headings\">\n    <tr>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">iterations</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">Rhat</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td class=\"gt_row gt_right\">20</td>\n<td class=\"gt_row gt_right\">1.77</td></tr>\n    <tr><td class=\"gt_row gt_right\">50</td>\n<td class=\"gt_row gt_right\">1.04</td></tr>\n    <tr><td class=\"gt_row gt_right\">100</td>\n<td class=\"gt_row gt_right\">1.22</td></tr>\n    <tr><td class=\"gt_row gt_right\">5000</td>\n<td class=\"gt_row gt_right\">1.01</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\n## Estimating the effective samples sizes\n\nAs we said before, the sample size is not equal to the number of iterations times the number of chains. There's an autocorrelation between the samples that we must take into account to find out how many equivalent independent samples from the posterior our iterations represent. To do so, we correct the number of total iterations by the sum of all autocorrelation lags $\\rho_t$:\n\n$$\ns_{eff} = \\dfrac{iterations * chains}{1 + 2\\sum^{\\infty} \\rho_t}\n$$\n\nWhich can be estimated for alpha thus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstan::ess_bulk(do.call(cbind, results$alpha))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1469.648\n```\n:::\n:::\n\n\nWe ran 5,000 iterations. Yet, we only have an effective sample size much smaller. Finally, for sigma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstan::ess_bulk(do.call(cbind, results$sigma))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1223.447\n```\n:::\n:::\n",
    "supporting": [
      "2020-06-29-bayesian-data-analysis-week-5-metropolis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}