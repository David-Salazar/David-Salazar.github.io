{
  "hash": "5e2a7258e7e6ce54d59a06b05b2b5a49",
  "result": {
    "markdown": "---\ntitle: Standard Deviation and Fat Tails\nauthor: David Salazar\ndate: '2020-05-13'\nslug: standard-deviation-and-fat-tails\ncategories: []\ntags: []\n---\n\n\n\n\n# Statistical Consequences of Fat Tails\n\nIn this post, I'll continue to explore with Monte-Carlo simulations the ideas in Nassim Taleb's latest book: [Statistical Consequences of Fat Tails](https://arxiv.org/abs/2001.10488). In other posts, I have look at [the persistent small sample effect that plagues the mean estimates under fat tails](2020-04-17-fat-vs-thin-does-lln-work.html) as a consequence of the loooong pre-asymptotics of the law of large numbers. Also, how this in turn plagues other statistical techniques [such as PCA](2020-04-27-spurious-pca-under-thick-tails.html). This time, I'll explore what Taleb finds out by turning his attention to the much misunderstood standard deviation. \n\n# Standard deviation under Fat Tails\n\nIn Chapter 4 of his book, Taleb explores how Standard Deviation (SD) is problematic: \n\n1. Widely misunderstood. People mistake Standard Deviation with Mean Absolute Deviation (MAD). \n1. That this confusion is benign under thin tailed distributions but an unforgivable mistake under fat tails.\n\nLet's try to replicate the second point. \n\n## Game Plan\n\nFirst, I'll begin by exploring in what sense, under a Gaussian, the Standard Deviation (SD) is more \"efficient estimator\" than the Mean Absolute Deviation (MAD). \n\nSecondly, in order to gauge the problems that start to arise with standard deviation (SD) as a measure of the scale of the distribution, Taleb uses the same trick as before: stochastize the volatility by switching between 2 normals with same means but different variances. The larger the difference between the variances, the fatter the tail of the resulting random variable. I tried to play with this idea in [this post](2020-05-09-what-does-it-mean-to-fatten-the-tails.html). Therefore, by analyzing the relationship between SD and MAD as we increase this difference, we get a type of derivative: as we increase the fat-tailedness, the difference between Standard Deviation (SD) and Mean Absolute Deviation (MAD) grows. \n\n## Efficiency in Mediocristan\n\nWhen deciding between estimators, statistics textbooks end up talking about two asymptotic properties of the estimator: consistency and efficiency. Consistency concerns itself with the asymptotic accuracy of an estimator and efficiency with the asymptotic variance of the estimator. That is, consistency means that the estimator with lots of observations has a distribution tightly centered around the parameter. Whereas efficiency is something more esoteric but it means that the asymptotic variance is the lowest it can possibly be. \n\n### Efficiency under the Poisson\n\nTo get some intuition around why we should care about the variance of an estimator, let's play with $X \\sim Poisson(\\lambda)$. Note that $E(X) = Var(X) = \\lambda$. We could use either the estimate for the mean or the variance to estimate $\\lambda$. Which is better?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_estimates <- function(size) {\n  sample <- rpois(size, lambda = 1)\n  mean_estimate <- mean(sample)\n  variance_estimate <- var(sample)\n  data.frame(sample_size = size, mean_estimate, variance_estimate) \n}\n\nmontecarlo_lambda <- function(size) {\n  rerun(1000, lambda_estimates(size)) %>% \n    bind_rows() %>% \n    pivot_longer(-sample_size, names_to = \"estimator\", values_to = \"estimate\")\n}\n\nc(10, 100, 500) %>% \n  map_df(montecarlo_lambda) %>% \n  mutate(sample_size = glue::glue(\"sample size: {sample_size}\")) -> lambda_est \nlambda_est %>% \n  ggplot(aes(x = estimate, y = sample_size)) +\n  geom_density_ridges(aes(fill = estimator), alpha = 0.5, color = \"black\") +\n  hrbrthemes::theme_ipsum_rc(grid = \"X\") +\n  theme(legend.position = \"bottom\") +\n  labs(x = \"\", \n       title = \"Estimating Poisson's lambda = 1\",\n       subtitle = \"Mean estimate has lower variance\",\n       caption = \"1000 monte carlo simulations for each sample size\") +\n  scale_fill_viridis_d()\n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThus, even though both estimators put a lot of their mass close to the true value, the Mean estimate has a lower variance than the Variance estimate of $\\lambda$. And therefore is a safer bet to estimate the $\\lambda$ parameter with the mean. Indeed, there's a mathematical bound for the variance of an estimator of $\\lambda$: $\\dfrac{\\lambda}{n}$ which only the mean estimator satisties. \n\nThis is an important results: **the variance estimate is too sensitive to outliers and we should prefer a natural weighting of the observations**. However, with a Poisson and its thin tails, this is no big deal.\n\nSo far, we have talked about the intuition. If one wanted to compare the two estimator's asymptotic efficiency, then one would compare the following ratio:\n\n$$ \\dfrac{(Var(S^2)}{Var(\\bar{X})} $$\n\nWhich is the asymptotic Relative efficiency of the two estimators. That is, which of them has a lower variance as the number of available observations becomes increasingly large. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmontecarlo_lambda_efficiency <- function(size) {\n  rerun(1000, lambda_estimates(size)) %>% \n    bind_rows() %>% \n    pivot_longer(-sample_size, names_to = \"estimator\", values_to = \"estimate\") %>% \n    group_by(sample_size, estimator) %>% \n    summarise(variance_estimator = var(estimate))\n}\n\nc(100, 500, 1000, 5000, 10000) %>% \n  map_df(montecarlo_lambda_efficiency) -> lambda_efficiency\n\nlambda_efficiency %>% \n  pivot_wider(sample_size, names_from = estimator, values_from = variance_estimator) %>% \n  mutate(are = variance_estimate/mean_estimate) %>% \n  ggplot(aes(x = sample_size, y = are)) +\n    geom_point() +\n    geom_line() +\n    scale_x_log10() +\n    expand_limits(x = 100, y = 0) +\n  hrbrthemes::theme_ipsum_rc(grid = \"Y\") + \n  labs(x = \"sample size (log scale)\",\n       y = \"Asymptotic Relative Efficiency\",\n       title = \"ARE Mean and Variance to estimate Poisson's lambda\",\n       subtitle = \"Mean estimate is ~ 3x more efficient\")\n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n### Efficiency under The Gaussian\n\nNow let's start playing with a Gaussian with known mean 0. Imagine you have to estimate the scale of the distribution, whatever that may mean. We have two candidates: the SD or the MAD. Which one should we prefer? Just as with the Poisson, let's play with with some Monte-Carlo simulations and calculate the ARE:\n\n$$  \\dfrac{(\\dfrac{Var(SD^2)}{E(SD)^2})}{(\\dfrac{Var({MAD})}{E({MAD})^2})} $$\n\nNote that SD and MAD are estimating different measures of the scale of the distribution Therefore, instead of comparing their variances, we compare their coefficients of variation. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngaussian_estimates <- function(size) {\n  sample <- rnorm(size)\n  standard_deviation <- sqrt(mean(sample^2))\n  mad <- sum(abs(sample))/size \n  data.frame(sample_size = size, standard_deviation, mad)\n}\n\nmontecarlo_sigma <- function(size) {\n  rerun(1000, gaussian_estimates(size)) %>% \n    bind_rows() %>% \n    pivot_longer(-sample_size, names_to = \"estimator\", values_to = \"estimate\") %>% \n    group_by(sample_size, estimator) %>% \n    summarise(variance_estimator = var(estimate)/mean(estimate)^2)\n}\n\nc(10, 100, 500, 1000, 10000, 20000, 50000 ) %>% \n  map_df(montecarlo_sigma) -> gaussian_est\n\ngaussian_est %>% \n  pivot_wider(sample_size, names_from = estimator, values_from = variance_estimator) %>% \n  mutate(are = standard_deviation/mad) %>% \n  ggplot(aes(sample_size, are)) +\n  geom_point() +\n  geom_line() +\n  geom_hline(aes(yintercept = 0.875), linetype = 2, color = \"red\") +\n   scale_x_log10() +\n    expand_limits(x = 100) +\n  scale_y_continuous(limits = c(0, 1)) +\n  hrbrthemes::theme_ipsum_rc(grid = \"Y\") +\n  labs(title = \"Asymptotic Relative Efficiency SD/MAD under Mediocristan\",\n       subtitle = \"Variance of SD is ~ 0.875 that of MAD\",\n       y = \"Asymptotic Relative Efficiency\",\n       x = \"Sample size (log scale)\",\n       caption = \"Red is theoretical ARE = 0.875\") \n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nGreat, as our results replicate what Taleb did with math.\n\nThus, in a strict sense, **when we are dealing with samples of Gaussian**, it is more efficient to use SD than MAD. However, what happens when we slip away into fatter-tails?\n\n## What happens to SD's efficiency as we fatten the tails?\n\nTaleb introduces an incredible heuristic ( [which I already examined in this post](2020-05-09-what-does-it-mean-to-fatten-the-tails.html) ) that works perfectly to get the intuition of fattening a distribution. In Taleb's words: \"The equivalent of a functional derivative that provides good grasp for local sensitivities\"\n\nThe heuristic is a simple **switching between two gaussians with different standard deviations**. Thus, we stochastize the variance of the distrbution. With probability $1-p$, we switch to a $Normal(0, \\sigma)$; with probability $p$, we switch to $Normal(0, \\sigma \\sqrt{(1+a)})$. \n\nThat is, if $p$ is small, there's a tiny probability that we switch to a gaussian with a higher standard deviation and that will likely generate outliers in comparison to the rest of the distribution. The higher $a$, the larger the scale of the distribution. Thus, **given that the tail probabilities are convex to the scale of the distribution, the higher $a$, the more we fatten the distribution**. Let's sample from this distribution to have a quick look:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate fattened\nfatten_simulations <- function(samples, a, p, sigma  = 1)  {\n  \n  # create vector to store sims\n  sims <- vector(length = samples)\n  # sample with probability p\n  p_location <- rbernoulli(samples, p = p)\n  \n  sims[p_location] <- rnorm(sum(p_location), sd = sigma *sqrt(1+a))\n  sims[!p_location] <- rnorm(sum(!p_location), sd = sigma)\n  return(sims)\n}\n\nsamples <- 10000\n# simulated fattened\na_s <- seq(0, 100, length.out = 5)\nnames(a_s) <- unlist(map(a_s, ~ glue::glue(\"a = {.x/5}\")))\n\na_s%>% \n  map_df(~ fatten_simulations(samples, a = .x, p = 0.01, sigma = 5)) %>% \n  mutate(simulation = 1:samples) %>% \n  pivot_longer(-simulation, names_to = \"a_s\") %>% \n  mutate(a_s = fct_inorder(a_s)) -> fattend_different_as\nfattend_different_as %>% \n  ggplot(aes(sample = value, color = a_s)) +\n  stat_qq(alpha = 0.4) +\n  stat_qq_line() +\n  scale_color_viridis_d(direction = -1) +\n  hrbrthemes::theme_ipsum_rc() +\n  labs(title = \"QQ-plot for different stochastic volatilties\",\n       subtitle = \"Tail values are convex to the scale of the distribution. Higher a, larger scale\",\n       color = \"\",\n       caption = \"Theoretical distribution is the normal. parameter a as a multiple of sigma\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nTherefore, if we calculate the ARE for different values of $a$, we are calculating its sensibility as we move close to fatter distributions. Let's check whether SD keeps being more efficient than MAD:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfatten_estimates <- function(size, a, p, sigma) {\n  sample <- fatten_simulations(size, a, p, sigma = sigma) \n  standard_deviation <- sqrt(mean(sample^2))\n  mad <- mean(abs(sample)) \n  data.frame(sample_size = size, standard_deviation, mad)\n}\n\nmontecarlo_sigma_fattened <- function(size, a, p, sigma) {\n  rerun(3000, fatten_estimates(size, a, p, sigma)) %>% \n    bind_rows() %>% \n    pivot_longer(-sample_size, names_to = \"estimator\", values_to = \"estimate\") %>% \n    group_by(estimator) %>% \n    summarise(variance_estimator = var(estimate)/mean(estimate)^2) %>% \n    mutate(a = a)\n}\n\na_s <- seq(0, 100, length.out = 40)\nnames(a_s) <- unlist(map(a_s, ~ glue::glue(\"a = {.x}\")))\na_s%>% \n  map_df(~montecarlo_sigma_fattened (size = 1000, a = .x, p = 0.01, sigma = 5)) ->fattened_are\nfattened_are %>% \n  pivot_wider(a, names_from = estimator, values_from = variance_estimator) %>% \n  mutate(are = standard_deviation/mad,\n         a = a / 5) %>% \n  ggplot(aes(a, are)) +\n  geom_point() +\n  expand_limits(x = 0, y = 0)  +\n  hrbrthemes::theme_ipsum_rc() +\n  labs(x = \"parameter a as a multiple of sigma\",\n       title = \"Asymptotic Relative Efficiency of SD vs MAD\",\n       subtitle = \"Small outliers (~ 2 SD upwards) eat away the efficiency of SD\",\n       y = \"Asymptotic Relative Efficiency\")\n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nPer Taleb:\n\n> A minute presence of outliers makes MAD more \"efﬁcient\" than STD. Small \"outliers\" of 5 standard deviations cause MAD to be ﬁve times more efﬁcient.\n\nTherefore, as we move towards distribution with fatter tails, we move to a place where standard deviation is worse than useless: it is dangerous. The problem compounds as the tails are precisely convex to the scale of the distribution. \n\nThus, to estimate the tails with SD is to play with fire: we are verly likely to make mistakes that will compound at the part of the distribution that matters the most. As Taleb says, this is also one of the misunderstandings of the Black Swan: the problem is not only that the extreme plays a large role; but also that we can very easily produce bogus estimates of the probabilities at the tail. \n\n### Why?\n\nThe problem arises from the weighting that SD performs. The larger the observation, the even larger weight will have on the Standard Deviation. Whereas MAD uses a more natural weighting, where the weight is equal to each observation. This becomes evident if we examine the cumulative SD and cumulative MAD, where every once in a while we get an extreme value. \n\nTo simulate this, let's sample from a Cauchy distribution where there is not even a defined first moment. In sample, however, we can calculate anything:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- rcauchy(10000)\ncumstd <- sqrt(cumvar(samples))\ncummad <- cummean(abs(samples - cummean(samples)))\n\ndata.frame(obs = 1:10000, cumstd, cummad) %>% \n  filter(obs > 2) %>% \n  pivot_longer(-obs) %>% \n  ggplot(aes(obs, value)) +\n    geom_line(aes(color = name)) +\n    hrbrthemes::theme_ipsum_rc(grid = \"Y\") +\n  scale_color_brewer(palette = \"Set1\") +\n  labs(color = \"\",\n       title = \"The SD is way too sensible to outliers\")\n```\n\n::: {.cell-output-display}\n![](2020-05-13-standard-deviation-and-fat-tails_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Conclusion\n\nSD is only optimal in Mediocristan. When we start moving toward Extremistan, SD blows up due to being a sum of squares. Even relatively small deviations wash away the efficiency of SD over MAD. Thus, when dealing with fat-tails, SD should not be used as it can lead to very imprecise estimates of the probability at the tails. Thus, SD is not an appropriate measure of the scale of the distribution for fat tails. It is much better to use the MAD. That is, **MAD is a better estimator of $E(|X-\\mu|)$ than SD as an estimator of $\\sigma$.**",
    "supporting": [
      "2020-05-13-standard-deviation-and-fat-tails_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}